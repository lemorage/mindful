from datetime import datetime, timezone
import logging
from typing import (
    Dict,
    List,
    Optional,
    Union,
)
from uuid import uuid4

from pydantic import (
    BaseModel,
    Field,
)

from mindful.models import TapeMetadata

logger = logging.getLogger("mindful")


class Tape(BaseModel):
    """
    A structured memory tape representing an atomic unit of knowledge.

    Designed for semantic retrieval, linking, lifecycle management, and evolutionary
    tracking within the mindful memory system. Attributes facilitate efficient
    storage and querying in various backends, including vector databases.

    Attributes:
        id (str): Universally unique identifier (UUID string). Serves as the primary key.
        role (str): Role associated with the content (e.g., 'user', 'assistant', 'system').
        content (str): Main textual content of the memory tape.
        embedding_vector (Optional[List[float]]): Dense vector representation for semantic search.
                                                 May be populated asynchronously or absent if embedding failed.
        metadata (TapeMetadata): Encapsulated semantic metadata generated by an agent,
                                 including fields like category, context, and keywords.
        links (Dict[str, str]): Links to other related Tape IDs, with the value describing
                                the relationship (e.g., {'tape_id_xyz': 'response_to'}).
                                Consider using a richer structure like List[LinkInfo] for typed links.
        related_queries (List[str]): User queries or prompts associated with this tape's
                                     creation or relevance. Useful for analysis.
        source (Optional[str]): Origin of the tape (e.g., 'interaction', 'document_ingestion',
                                'agent_summary', 'evolution'). Aids provenance tracking.
        access_count (int): Counter for how often this tape has been retrieved or accessed.
                            Used for relevance re-ranking and lifecycle management.
        priority (int): Importance score (1-10, default 5), influencing retrieval ranking
                        and potential evolution actions.
        last_accessed (Optional[datetime]): Timestamp (UTC) when the tape was last retrieved
                                           or marked as accessed. None if never accessed.
        created_at (datetime): Timestamp (UTC) when the tape was originally created.
        updated_at (datetime): Timestamp (UTC) when the tape was last modified (content, links, etc.).
        versions (List[Dict[str, Union[str, datetime]]]): History of significant content modifications,
                                                        storing previous content and update timestamp.
        status (str): Lifecycle status of the tape (e.g., 'active', 'archived', 'deleted').
                      Defaults to 'active'. Used for filtering during retrieval and evolution tasks.
    """

    # --- Core Identifiers & Content ---
    id: str = Field(
        default_factory=lambda: str(uuid4()), description="Universally unique identifier (UUID string). Primary key."
    )
    role: str = Field(..., description="Role associated with the content (e.g., 'user', 'assistant').")
    content: str = Field(..., description="Main textual content of the memory tape.")
    embedding_vector: Optional[List[float]] = Field(
        None, description="Dense vector representation for semantic search and retrieval."
    )

    # --- Dynamic Metadata ---
    metadata: TapeMetadata = Field(default_factory=TapeMetadata, description="Encapsulated semantic metadata.")

    # --- Linking & Provenance ---
    links: Dict[str, str] = Field(default_factory=dict, description="Bidirectional links to related memory notes.")
    related_queries: List[str] = Field(
        default_factory=list, description="Similar or related queries linked to this note."
    )
    source: Optional[str] = Field(None, description="Origin of the tape (e.g., 'interaction', 'evolution').")

    # --- Usage & Importance Tracking ---
    access_count: int = Field(0, ge=0, description="Number of times retrieved/accessed.")
    priority: int = Field(5, ge=1, le=10, description="Importance score (1-10).")
    last_accessed: Optional[datetime] = Field(None, description="Timestamp (UTC) when last accessed.")

    # --- Temporal Tracking (UTC) ---
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc), description="Timestamp (UTC) created."
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc), description="Timestamp (UTC) last modified."
    )

    # --- Evolution & Lifecycle ---
    versions: List[Dict[str, Union[str, datetime]]] = Field(
        default_factory=list, description="History of modifications and updates."
    )
    status: str = Field("active", description="Lifecycle status (e.g., 'active', 'archived').")

    class Config:
        validate_assignment = True

    def update_content(self, new_content: str, reason: Optional[str] = None) -> None:
        """
        Update the content of the note while preserving the version history.

        This method appends the previous content to the `versions` list before updating the
        note's content and timestamp.

        Args:
            new_content (str): The new content to replace the existing content.
            reason (str, optional): Reason for the update. Defaults to None.
        """
        if new_content == self.content:
            return
        self.versions.append({"content": self.content, "timestamp": self.updated_at})
        self.content = new_content
        self.updated_at = datetime.now(timezone.utc)

    def add_link(self, related_tape_id: str, description: str) -> None:
        """
        Establish a bidirectional link between this note and another.

        Args:
            related_tape_id (str): The unique identifier of the related note.
            description (str): A brief explanation of the relationship between the notes.
        """
        # Add check to prevent self-linking?
        if related_tape_id == self.id:
            return
        self.links[related_tape_id] = description
        self.updated_at = datetime.now(timezone.utc)

    def mark_accessed(self) -> None:
        """Updates access metadata. Call when the tape is retrieved/used."""
        self.access_count += 1
        self.last_accessed = datetime.now(timezone.utc)
        # Note: This updates the in-memory object. Persistence is handled by TapeDeck calling storage.update_tape.
        logger.debug(f"Marked tape {self.id} accessed in-memory. Count: {self.access_count}")
