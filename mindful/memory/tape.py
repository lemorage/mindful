from datetime import datetime, timezone
import math
import logging
from typing import (
    Any,
    Dict,
    List,
    Optional,
    Tuple,
    Union,
)
from uuid import uuid4

import numpy as np
from pydantic import (
    BaseModel,
    Field,
)

from mindful.agent import MindfulAgent
from mindful.models import TapeMetadata

logger = logging.getLogger("mindful")


class Tape(BaseModel):
    """
    A structured memory tape representing an atomic unit of knowledge.

    Designed for semantic retrieval, linking, lifecycle management, and evolutionary
    tracking within the mindful memory system. Attributes facilitate efficient
    storage and querying in various backends, including vector databases.

    Attributes:
        id (str): Universally unique identifier (UUID string). Serves as the primary key.
        role (str): Role associated with the content (e.g., 'user', 'assistant', 'system').
        content (str): Main textual content of the memory tape.
        embedding_vector (Optional[List[float]]): Dense vector representation for semantic search.
                                                 May be populated asynchronously or absent if embedding failed.
        metadata (TapeMetadata): Encapsulated semantic metadata generated by an agent,
                                 including fields like category, context, and keywords.
        links (Dict[str, str]): Links to other related Tape IDs, with the value describing
                                the relationship (e.g., {'tape_id_xyz': 'response_to'}).
                                Consider using a richer structure like List[LinkInfo] for typed links.
        related_queries (List[str]): User queries or prompts associated with this tape's
                                     creation or relevance. Useful for analysis.
        source (Optional[str]): Origin of the tape (e.g., 'interaction', 'document_ingestion',
                                'agent_summary', 'evolution'). Aids provenance tracking.
        access_count (int): Counter for how often this tape has been retrieved or accessed.
                            Used for relevance re-ranking and lifecycle management.
        priority (int): Importance score (1-10, default 5), influencing retrieval ranking
                        and potential evolution actions.
        last_accessed (Optional[datetime]): Timestamp (UTC) when the tape was last retrieved
                                           or marked as accessed. None if never accessed.
        created_at (datetime): Timestamp (UTC) when the tape was originally created.
        updated_at (datetime): Timestamp (UTC) when the tape was last modified (content, links, etc.).
        versions (List[Dict[str, Union[str, datetime]]]): History of significant content modifications,
                                                        storing previous content and update timestamp.
        status (str): Lifecycle status of the tape (e.g., 'active', 'archived', 'deleted').
                      Defaults to 'active'. Used for filtering during retrieval and evolution tasks.
    """

    # --- Core Identifiers & Content ---
    id: str = Field(
        default_factory=lambda: str(uuid4()), description="Universally unique identifier (UUID string). Primary key."
    )
    role: str = Field(..., description="Role associated with the content (e.g., 'user', 'assistant').")
    content: str = Field(..., description="Main textual content of the memory tape.")
    embedding_vector: Optional[List[float]] = Field(
        None, description="Dense vector representation for semantic search and retrieval."
    )

    # --- Dynamic Metadata ---
    metadata: TapeMetadata = Field(default_factory=TapeMetadata, description="Encapsulated semantic metadata.")

    # --- Linking & Provenance ---
    links: Dict[str, str] = Field(default_factory=dict, description="Bidirectional links to related memory notes.")
    related_queries: List[str] = Field(
        default_factory=list, description="Similar or related queries linked to this note."
    )
    source: Optional[str] = Field(None, description="Origin of the tape (e.g., 'interaction', 'evolution').")

    # --- Usage & Importance Tracking ---
    access_count: int = Field(0, ge=0, description="Number of times retrieved/accessed.")
    priority: int = Field(5, ge=1, le=10, description="Importance score (1-10).")
    last_accessed: Optional[datetime] = Field(None, description="Timestamp (UTC) when last accessed.")

    # --- Temporal Tracking (UTC) ---
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc), description="Timestamp (UTC) created."
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc), description="Timestamp (UTC) last modified."
    )

    # --- Evolution & Lifecycle ---
    versions: List[Dict[str, Union[str, datetime]]] = Field(
        default_factory=list, description="History of modifications and updates."
    )
    status: str = Field("active", description="Lifecycle status (e.g., 'active', 'archived').")

    class Config:
        validate_assignment = True

    def update_content(self, new_content: str, reason: Optional[str] = None) -> None:
        """
        Update the content of the note while preserving the version history.

        This method appends the previous content to the `versions` list before updating the
        note's content and timestamp.

        Args:
            new_content (str): The new content to replace the existing content.
            reason (str, optional): Reason for the update. Defaults to None.
        """
        if new_content == self.content:
            return
        self.versions.append({"content": self.content, "timestamp": self.updated_at})
        self.content = new_content
        self.updated_at = datetime.now(timezone.utc)

    def add_link(self, related_tape_id: str, description: str) -> None:
        """
        Establish a bidirectional link between this note and another.

        Args:
            related_tape_id (str): The unique identifier of the related note.
            description (str): A brief explanation of the relationship between the notes.
        """
        # Add check to prevent self-linking?
        if related_tape_id == self.id:
            return
        self.links[related_tape_id] = description
        self.updated_at = datetime.now(timezone.utc)

    def mark_accessed(self) -> None:
        """Updates access metadata. Call when the tape is retrieved/used."""
        self.access_count += 1
        self.last_accessed = datetime.now(timezone.utc)
        # Note: This updates the in-memory object. Persistence is handled by TapeDeck calling storage.update_tape.
        logger.debug(f"Marked tape {self.id} accessed in-memory. Count: {self.access_count}")


class TapeDeck:
    """A memory management system for storing and retrieving Tape objects."""

    def __init__(self, provider_name: str) -> None:
        self.tapes: Dict[str, Tape] = {}
        self.agent = MindfulAgent(provider_name)

    def add_tape(self, content: str, role: str) -> Tape:
        """
        Add a new Tape to the deck from raw content and role.
        Automatically handles embedding and placeholder metadata.

        Returns:
            Tape: The created and stored Tape object.
        """
        # Stub/default metadata
        category, context, keywords = self.agent.generate_metadata(content)
        category, context = (category or ""), (context or "")
        embedding_vector = self.agent.embed(content) or []

        # TODO: can later be executed through tool calling by an agent, empty for now
        links: Dict[str, str] = {}
        related_queries: List[str] = []

        # Create the Tape
        tape = Tape(
            content=content,
            role=role,
            metadata=TapeMetadata(category=category, context=context, keywords=keywords),
            links=links,
            related_queries=related_queries,
            embedding_vector=embedding_vector,
        )

        self.tapes[tape.id] = tape
        return tape

    def get_tape(self, tape_id: str) -> Optional[Tape]:
        """Retrieve a Tape by ID and update access metadata."""
        tape = self.tapes.get(tape_id)
        if tape:
            tape.access_count += 1
            tape.last_accessed = datetime.now()
        return tape

    def update_tape(self, tape_id: str, new_content: str) -> None:
        """Update a Tape's content and embedding."""
        tape = self.get_tape(tape_id)
        if tape:
            tape.update_content(new_content)
            tape.embedding_vector = self.agent.embed(new_content) or []

    def delete_tape(self, tape_id: str) -> None:
        """Delete a Tape by ID."""
        if tape_id in self.tapes:
            del self.tapes[tape_id]

    def link_tapes(self, tape_id1: str, tape_id2: str, description: str) -> None:
        """Create a bidirectional link between two Tapes."""
        tape1 = self.get_tape(tape_id1)
        tape2 = self.get_tape(tape_id2)
        if tape1 and tape2:
            tape1.add_link(tape_id2, description)
            tape2.add_link(tape_id1, f"replied_by_{description}")

    def retrieve_relevant(self, query: str, top_k: int = 5) -> List[Tape]:
        """Retrieve relevant Tapes using embeddings if available, otherwise keywords."""
        if any(t.embedding_vector for t in self.tapes.values()):
            query_embedding = self.agent.embed(query)
            scores = {}
            for tape in self.tapes.values():
                if tape.embedding_vector:
                    # Cosine similarity
                    dot_product = np.dot(query_embedding, tape.embedding_vector)
                    norm = np.linalg.norm(query_embedding) * np.linalg.norm(tape.embedding_vector)
                    similarity = dot_product / norm if norm > 0 else 0

                    # priority 10 = 1.5x, priority 1 = 1.0x
                    weighted_score = similarity * (1 + (tape.priority - 1) * 0.05)
                    scores[tape.id] = weighted_score
            sorted_tapes = sorted(scores.items(), key=lambda x: x[1], reverse=True)[:top_k]
            return [self.tapes[tid] for tid, _ in sorted_tapes]
        else:
            # Fallback to keyword matching
            keywords = set(query.lower().split())
            scores = {}
            for tape in self.tapes.values():
                tape_keywords = set(tape.metadata.keywords)
                score = len(keywords.intersection(tape_keywords))
                if score > 0:
                    weighted_score = score * (1 + (tape.priority - 1) * 0.05)
                    scores[tape.id] = weighted_score
            sorted_tapes = sorted(scores.items(), key=lambda x: x[1], reverse=True)[:top_k]
            return [self.tapes[tid] for tid, _ in sorted_tapes]
